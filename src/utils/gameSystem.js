// ============================================================================
// üìä DECK CONFIGURATION (‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î)
// ============================================================================
// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î "‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏™‡πà‡∏ß‡∏ô" ‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏õ‡∏£‡∏≤‡∏Å‡∏è‡πÉ‡∏ô‡πÄ‡∏Å‡∏°
const DECK_COMPOSITION = {
  E: 8, A: 8, I: 8, O: 8, N: 6, R: 6, T: 6, 
  L: 4, S: 4, U: 4, D: 4, G: 3, B: 2, C: 2, 
  M: 2, P: 2, F: 2, H: 2, V: 2, W: 2, Y: 2, 
  K: 1, J: 1, X: 1, QU: 1, Z: 1 
};

// ‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô "‡∏™‡∏£‡∏∞" (‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Logic ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏™‡∏°‡∏î‡∏∏‡∏•)
const VOWELS = ['A', 'E', 'I', 'O', 'U'];

export const DeckManager = {
  // üé¥ activeDeck: ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Å‡∏≠‡∏á‡∏à‡∏±‡πà‡∏ß‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
  activeDeck: [],

  // ============================================================================
  // 1. Core Logic (‡∏™‡πà‡∏ß‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏™‡∏∏‡πà‡∏°)
  // ============================================================================

  // üîπ init(): ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Å‡∏≠‡∏á‡πÑ‡∏û‡πà‡πÉ‡∏´‡∏°‡πà ‡πÅ‡∏•‡∏∞‡∏™‡∏±‡∏ö‡πÑ‡∏û‡πà
  init() {
    let tempDeck = [];
    
    // 1. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏ô Config
    Object.keys(DECK_COMPOSITION).forEach((char) => {
      for (let i = 0; i < DECK_COMPOSITION[char]; i++) {
        tempDeck.push(char);
      }
    });

    // 2. ‡∏™‡∏±‡∏ö‡πÑ‡∏û‡πà (Shuffle) ‡∏î‡πâ‡∏ß‡∏¢ Fisher-Yates Algorithm
    // (‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÑ‡∏û‡πà‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏ï‡∏±‡∏ß‡πÅ‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏°‡∏à‡∏£‡∏¥‡∏á‡πÜ)
    for (let i = tempDeck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [tempDeck[i], tempDeck[j]] = [tempDeck[j], tempDeck[i]];
    }

    this.activeDeck = tempDeck;
    console.log(`üé¥ Deck Initialized: ${this.activeDeck.length} cards.`);
  },

  // üîπ draw(): ‡∏à‡∏±‡πà‡∏ß‡πÑ‡∏û‡πà 1 ‡πÉ‡∏ö ‡πÇ‡∏î‡∏¢‡∏°‡∏µ AI ‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡πÑ‡∏û‡πà‡πÄ‡∏ô‡πà‡∏≤‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
  // - currentInventory: ‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏Ç‡∏≠‡∏á‡πÉ‡∏ô‡∏°‡∏∑‡∏≠‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Å‡∏±‡∏ô‡∏ã‡πâ‡∏≥)
  // - unlockedSlots: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ (‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÇ‡∏Ñ‡∏ß‡∏ï‡∏≤‡∏™‡∏£‡∏∞)
  draw(currentInventory = [], unlockedSlots = 10) {
    // ‡∏ñ‡πâ‡∏≤‡∏Å‡∏≠‡∏á‡πÑ‡∏û‡πà‡∏´‡∏°‡∏î ‡πÉ‡∏´‡πâ‡∏•‡πâ‡∏≤‡∏á‡πÑ‡∏û‡πà‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
    if (this.activeDeck.length === 0) this.init();

    // ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏°‡∏∑‡∏≠‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏°‡∏≤‡πÄ‡∏ä‡πá‡∏Ñ
    const existingChars = currentInventory
      .filter((slot) => slot !== null)
      .map((slot) => slot.char.toUpperCase());

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡πÉ‡∏ô‡∏°‡∏∑‡∏≠
    const vowelCount = existingChars.filter((c) => VOWELS.includes(c)).length;
    // ‡πÄ‡∏û‡∏î‡∏≤‡∏ô‡∏™‡∏£‡∏∞: ‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏™‡∏£‡∏∞‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏ä‡πà‡∏≠‡∏á
    const vowelCeiling = Math.max(2, Math.floor(unlockedSlots / 2));
    
    // ‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏¢‡∏≤‡∏Å
    const hardChars = ["K", "J", "X", "QU", "Z"];
    const hasHardInHand = existingChars.some((c) => hardChars.includes(c));

    let foundIdx = -1;

    // ‡∏ß‡∏ô‡∏´‡∏≤‡πÑ‡∏û‡πà‡∏à‡∏≤‡∏Å‡∏ó‡πâ‡∏≤‡∏¢‡∏Å‡∏≠‡∏á (i--) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤‡πÉ‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
    for (let i = this.activeDeck.length - 1; i >= 0; i--) {
      const candidate = this.activeDeck[i].toUpperCase();
      const isVowel = VOWELS.includes(candidate);
      const countInHand = existingChars.filter((c) => c === candidate).length;

      // --- üö¶ ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏Ñ‡∏±‡∏î‡∏Å‡∏£‡∏≠‡∏á (Filtering Rules) ---

      // 1. ‡∏ñ‡πâ‡∏≤‡∏™‡∏£‡∏∞‡πÄ‡∏ï‡πá‡∏°‡πÇ‡∏Ñ‡∏ß‡∏ï‡πâ‡∏≤‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡πâ‡∏≤‡∏°‡∏´‡∏¢‡∏¥‡∏ö‡∏™‡∏£‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°
      if (vowelCount >= vowelCeiling && isVowel) continue;

      // 2. ‡∏ñ‡πâ‡∏≤‡∏™‡∏£‡∏∞‡∏Ç‡∏≤‡∏î‡πÅ‡∏Ñ‡∏•‡∏ô (< 2) ‡πÅ‡∏•‡∏∞‡πÉ‡∏ö‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏™‡∏£‡∏∞ ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ‡∏Å‡πà‡∏≠‡∏ô (‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏´‡∏≤‡∏™‡∏£‡∏∞)
      // (‡πÅ‡∏ï‡πà‡∏ñ‡πâ‡∏≤‡πÑ‡∏û‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 10 ‡πÉ‡∏ö ‡∏¢‡∏≠‡∏°‡∏´‡∏¢‡∏¥‡∏ö‡∏≠‡∏∞‡πÑ‡∏£‡∏Å‡πá‡πÑ‡∏î‡πâ ‡∏Å‡∏±‡∏ô‡πÄ‡∏Å‡∏°‡∏Ñ‡πâ‡∏≤‡∏á)
      if (vowelCount < 2 && !isVowel && this.activeDeck.length > 10) continue;

      // 3. ‡∏´‡πâ‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡∏ã‡πâ‡∏≥‡πÄ‡∏Å‡∏¥‡∏ô 2 ‡πÉ‡∏ö ‡πÅ‡∏•‡∏∞‡∏´‡πâ‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡∏¢‡∏≤‡∏Å‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô
      const isTooManyIdentical = countInHand >= 2;
      const isTooManyHard = hasHardInHand && hardChars.includes(candidate);

      if (!isTooManyIdentical && !isTooManyHard) {
        foundIdx = i; // ‡πÄ‡∏à‡∏≠‡πÉ‡∏ö‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç
        break;
      }
    }

    // --- üèÅ ‡∏Å‡∏≤‡∏£‡∏´‡∏¢‡∏¥‡∏ö‡∏à‡∏£‡∏¥‡∏á ---
    if (foundIdx !== -1) {
      return this.activeDeck.splice(foundIdx, 1)[0]; // ‡∏´‡∏¢‡∏¥‡∏ö‡πÉ‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
    } else {
      return this.activeDeck.pop(); // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡πÉ‡∏ö‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏Å‡∏é‡πÄ‡∏•‡∏¢ ‡πÉ‡∏´‡πâ‡∏´‡∏¢‡∏¥‡∏ö‡πÉ‡∏ö‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏ï‡∏≤‡∏°‡∏î‡∏ß‡∏á
    }
  },

  // ============================================================================
  // 2. Item Factory (‡πÇ‡∏£‡∏á‡∏á‡∏≤‡∏ô‡∏ú‡∏•‡∏¥‡∏ï‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏° - ‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•)
  // ============================================================================

  // üîπ createItem(): ‡∏™‡∏£‡πâ‡∏≤‡∏á Object ‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏° 1 ‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå
  // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡∏à‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡∏ô‡∏µ‡πâ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Object ‡πÄ‡∏≠‡∏á
  createItem(index, currentInv = [], unlockedSlots = 10) {
    // 1. ‡∏Ç‡∏≠‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏à‡∏≤‡∏Å draw (‡∏™‡πà‡∏á currentInv ‡πÑ‡∏õ‡πÉ‡∏´‡πâ draw ‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏ä‡πá‡∏Ñ‡∏ï‡∏±‡∏ß‡∏ã‡πâ‡∏≥)
    const char = this.draw(currentInv, unlockedSlots);

    // 2. ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô Object ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡∏°
    return {
      id: Math.random(),      // Unique Key ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö React
      char: char,             // ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£
      status: null,           // ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏û‡∏¥‡πÄ‡∏®‡∏© (poison, stun)
      statusDuration: 0,      // ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
      visible: true,          // ‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
      originalIndex: index,   // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡∏≠‡∏á (0, 1, 2...)
    };
  },

  // ============================================================================
  // 3. Inventory Tools (‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡πÄ‡∏õ‡πã‡∏≤)
  // ============================================================================

  // üîπ generateList(): ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏∞‡πÄ‡∏õ‡πã‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡πÄ‡∏ä‡πà‡∏ô ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà)
  generateList(count) {
    let list = new Array(count).fill(null);
    for (let i = 0; i < count; i++) {
      // ‚úÖ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å createItem ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏ã‡πâ‡∏≥
      // ‡∏™‡πà‡∏á 'list' ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ draw() ‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤‡πÄ‡∏£‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏á‡∏´‡∏¢‡∏¥‡∏ö‡∏≠‡∏∞‡πÑ‡∏£‡πÑ‡∏õ‡∏ö‡πâ‡∏≤‡∏á‡πÉ‡∏ô Loop ‡∏ô‡∏µ‡πâ
      list[i] = this.createItem(i, list, count);
    }
    return list;
  },

  // üîπ fillEmptySlots(): ‡πÄ‡∏ï‡∏¥‡∏°‡∏Ç‡∏≠‡∏á‡πÉ‡∏™‡πà‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á (‡πÉ‡∏ä‡πâ‡∏´‡∏•‡∏±‡∏á‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡πÄ‡∏™‡∏£‡πá‡∏à)
  fillEmptySlots(currentInv, reservedIndices, limit) {
    let nextInv = [...currentInv]; // Copy Array ‡∏Å‡∏±‡∏ô‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏ï‡∏±‡∏ß‡πÅ‡∏°‡πà
    
    for (let i = 0; i < limit; i++) {
      // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á (null) ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏ï‡∏¥‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏à‡∏≠‡∏á (reserved)
      if (!reservedIndices.includes(i) && nextInv[i] === null) {
        // ‚úÖ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å createItem ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ï‡∏¥‡∏°‡∏Ç‡∏≠‡∏á
        nextInv[i] = this.createItem(i, nextInv, limit);
      }
    }
    return nextInv;
  },

  // üîπ returnItems(): ‡∏Ñ‡∏∑‡∏ô‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏£‡∏∞‡πÄ‡∏õ‡πã‡∏≤ (‡πÉ‡∏ä‡πâ‡∏ï‡∏≠‡∏ô‡∏Å‡∏î‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å ‡∏´‡∏£‡∏∑‡∏≠‡∏ß‡∏≤‡∏á‡∏ú‡∏¥‡∏î)
  returnItems(currentInv, itemsToReturn, limit) {
    const nextInv = [...currentInv];
    
    itemsToReturn.forEach((item) => {
      // ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ô‡∏ó‡∏µ‡πà‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏Å‡πà‡∏≠‡∏ô
      let targetIdx = item.originalIndex;

      // ‡∏ñ‡πâ‡∏≤‡∏ä‡πà‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏á ‡πÉ‡∏´‡πâ‡∏´‡∏≤‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡∏ä‡πà‡∏≠‡∏á‡πÅ‡∏£‡∏Å‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≠
      if (nextInv[targetIdx] !== null) {
        const emptyIdx = nextInv.findIndex((x, i) => x === null && i < limit);
        if (emptyIdx !== -1) targetIdx = emptyIdx;
      }
      
      // ‡∏ß‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô
      nextInv[targetIdx] = item;
    });
    
    return nextInv;
  },
};
// --- üó£Ô∏è Word System ---
export const WordSystem = {
  // ‡∏™‡∏∏‡πà‡∏°‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡∏à‡∏≤‡∏Å Dictionary ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ (‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏û‡∏π‡∏î‡∏®‡∏±‡∏ï‡∏£‡∏π)
  getRandomWordByLength: (dictionary, length) => {
    const candidates = dictionary.filter((d) => d.word.length === length);
    if (candidates.length > 0) {
      const randomIndex = Math.floor(Math.random() * candidates.length);
      return candidates[randomIndex].word.toUpperCase();
    }
    
    // Fallback ‡∏Å‡∏£‡∏ì‡∏µ‡∏´‡∏≤‡∏Ñ‡∏≥‡πÉ‡∏ô Dictionary ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠
    const fallbackChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let result = "";
    for (let i = 0; i < length; i++) {
      result += fallbackChars.charAt(
        Math.floor(Math.random() * fallbackChars.length)
      );
    }
    return result;
  },
  getLevenshteinDistance: (a, b) => {
    const matrix = [];
    for (let i = 0; i <= b.length; i++) matrix[i] = [i];
    for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
    for (let i = 1; i <= b.length; i++) {
      for (let j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) === a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    return matrix[b.length][a.length];
  },

  
};